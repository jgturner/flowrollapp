// Production-ready Mux service using the official Mux Node.js SDK
// This file shows how to integrate with the actual Mux API

import Mux from '@mux/mux-node';

export interface MuxUploadResponse {
  uploadUrl: string;
  uploadId: string;
  status: string;
}

export interface MuxAssetStatus {
  status: 'processing' | 'ready' | 'errored';
  assetId?: string;
  playbackId?: string;
  message: string;
}

export interface MuxThumbnail {
  time: number;
  url: string;
}

export class MuxProductionService {
  private static instance: MuxProductionService;
  private muxClient: Mux;

  private constructor() {
    // Initialize Mux client with credentials from environment variables
    this.muxClient = new Mux({
      tokenId: process.env.MUX_TOKEN_ID!,
      tokenSecret: process.env.MUX_TOKEN_SECRET!,
    });
  }

  public static getInstance(): MuxProductionService {
    if (!MuxProductionService.instance) {
      MuxProductionService.instance = new MuxProductionService();
    }
    return MuxProductionService.instance;
  }

  /**
   * Create a new direct upload for video content
   */
  async createUpload(filename: string, fileSize: number): Promise<MuxUploadResponse> {
    try {
      // Create upload with Mux API
      const upload = await this.muxClient.Video.Uploads.create({
        new_asset_settings: {
          playback_policy: ['public'],
          mp4_support: 'standard',
          // Enable static renditions for better performance
          static_renditions: [{ resolution: '1080p' }, { resolution: '720p' }, { resolution: '480p' }],
        },
        cors_origin: '*',
        timeout: 3600, // 1 hour timeout
      });

      return {
        uploadUrl: upload.url,
        uploadId: upload.id,
        status: 'waiting',
      };
    } catch (error) {
      console.error('Error creating Mux upload:', error);
      throw new Error('Failed to create upload URL');
    }
  }

  /**
   * Check the status of an upload and get asset details
   */
  async getUploadStatus(uploadId: string): Promise<MuxAssetStatus> {
    try {
      // Get upload status from Mux
      const upload = await this.muxClient.Video.Uploads.get(uploadId);

      if (upload.status === 'errored') {
        return {
          status: 'errored',
          message: upload.error?.message || 'Upload failed',
        };
      }

      if (upload.status === 'waiting') {
        return {
          status: 'processing',
          message: 'Video is still being processed...',
        };
      }

      if (upload.status === 'asset_created' && upload.asset_id) {
        // Get asset details
        const asset = await this.muxClient.Video.Assets.get(upload.asset_id);

        if (asset.status === 'ready' && asset.playback_ids && asset.playback_ids.length > 0) {
          return {
            status: 'ready',
            assetId: asset.id,
            playbackId: asset.playback_ids[0].id,
            message: 'Video processing complete',
          };
        } else if (asset.status === 'errored') {
          return {
            status: 'errored',
            message: asset.error?.message || 'Asset processing failed',
          };
        } else {
          return {
            status: 'processing',
            message: 'Asset is still being processed...',
          };
        }
      }

      return {
        status: 'processing',
        message: 'Upload is being processed...',
      };
    } catch (error) {
      console.error('Error checking upload status:', error);
      return {
        status: 'errored',
        message: 'Failed to check upload status',
      };
    }
  }

  /**
   * Generate thumbnail URLs for a playback ID
   * These are generated by Mux at different timestamps
   */
  generateThumbnails(playbackId: string): MuxThumbnail[] {
    const timestamps = [0, 10, 20, 30, 45, 60];
    return timestamps.map((time) => ({
      time,
      url: `https://image.mux.com/${playbackId}/thumbnail.jpg?width=320&time=${time}`,
    }));
  }

  /**
   * Get video playback URL for a playback ID
   */
  getPlaybackUrl(playbackId: string): string {
    return `https://stream.mux.com/${playbackId}.m3u8`;
  }

  /**
   * Get MP4 download URL for a playback ID (if available)
   */
  getMp4Url(playbackId: string): string {
    return `https://stream.mux.com/${playbackId}/high.mp4`;
  }

  /**
   * Delete an asset and its associated upload
   */
  async deleteAsset(assetId: string): Promise<void> {
    try {
      await this.muxClient.Video.Assets.del(assetId);
    } catch (error) {
      console.error('Error deleting asset:', error);
      throw new Error('Failed to delete asset');
    }
  }

  /**
   * Get asset details
   */
  async getAsset(assetId: string) {
    try {
      return await this.muxClient.Video.Assets.get(assetId);
    } catch (error) {
      console.error('Error getting asset:', error);
      throw new Error('Failed to get asset details');
    }
  }

  /**
   * List all assets for monitoring
   */
  async listAssets(limit: number = 100) {
    try {
      return await this.muxClient.Video.Assets.list({ limit });
    } catch (error) {
      console.error('Error listing assets:', error);
      throw new Error('Failed to list assets');
    }
  }

  /**
   * Get upload statistics for monitoring
   */
  async getStats() {
    try {
      const [assets, uploads] = await Promise.all([this.muxClient.Video.Assets.list({ limit: 1000 }), this.muxClient.Video.Uploads.list({ limit: 1000 })]);

      return {
        totalAssets: assets.length,
        totalUploads: uploads.length,
        readyAssets: assets.filter((a) => a.status === 'ready').length,
        processingAssets: assets.filter((a) => a.status === 'preparing').length,
        erroredAssets: assets.filter((a) => a.status === 'errored').length,
        waitingUploads: uploads.filter((u) => u.status === 'waiting').length,
        completedUploads: uploads.filter((u) => u.status === 'asset_created').length,
        erroredUploads: uploads.filter((u) => u.status === 'errored').length,
      };
    } catch (error) {
      console.error('Error getting stats:', error);
      return {
        totalAssets: 0,
        totalUploads: 0,
        readyAssets: 0,
        processingAssets: 0,
        erroredAssets: 0,
        waitingUploads: 0,
        completedUploads: 0,
        erroredUploads: 0,
      };
    }
  }

  /**
   * Create a signed URL for secure video playback
   */
  createSignedUrl(playbackId: string, expiresIn: number = 3600): string {
    // In production, you would use Mux's signing service
    // For now, return the public URL
    return this.getPlaybackUrl(playbackId);
  }

  /**
   * Generate subtitles for an asset using Mux's automatic speech recognition
   */
  async generateSubtitles(assetId: string, languageCode: string = 'en') {
    try {
      const track = await this.muxClient.Video.Assets.createTrack(assetId, {
        url: undefined, // No URL for auto-generation
        type: 'text',
        text_type: 'subtitles',
        language_code: languageCode,
        name: `${languageCode} Subtitles`,
        generated_subtitles: {
          language_code: languageCode,
          name: `${languageCode} Subtitles`,
        },
      });

      return track;
    } catch (error) {
      console.error('Error generating subtitles:', error);
      throw new Error('Failed to generate subtitles');
    }
  }
}

// Export singleton instance
export const muxProductionService = MuxProductionService.getInstance();

// Usage example:
// To switch from mock service to production service:
// 1. Install Mux SDK: npm install @mux/mux-node
// 2. Set environment variables: MUX_TOKEN_ID and MUX_TOKEN_SECRET
// 3. Replace muxService with muxProductionService in your API routes
